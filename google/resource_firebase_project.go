// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    AUTO GENERATED CODE     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"fmt"
	"log"
	"reflect"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
)

func resourceFirebaseProject() *schema.Resource {
	return &schema.Resource{
		Create: resourceFirebaseProjectCreate,
		Read:   resourceFirebaseProjectRead,
		Update: resourceFirebaseProjectUpdate,
		Delete: resourceFirebaseProjectDelete,

		Importer: &schema.ResourceImporter{
			State: resourceFirebaseProjectImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(4 * time.Minute),
			Update: schema.DefaultTimeout(4 * time.Minute),
			Delete: schema.DefaultTimeout(4 * time.Minute),
		},

		Schema: map[string]*schema.Schema{
			"resources": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: `The default resources associated with a FirebaseProject.`,
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"hosting_site": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The default Firebase Hosting site name, in the format: projectId
Though rare, your projectId might already be used as the name for an existing Hosting site in another project
(learn more about creating non-default, additional sites).
In these cases, your projectId is appended with a hyphen then five alphanumeric characters to create your default Hosting site name.
For example, if your projectId is myproject123, your default Hosting site name might be: myproject123-a5c1`,
						},
						"location_id": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The ID of the project's default GCP resource location. The location is one of the available GCP resource locations.
This field is omitted if the default GCP resource location has not been finalized yet.
To set your project's default GCP resource location, call defaultLocation.finalize after you add Firebase services to your project.`,
						},
						"realtime_database_instance": {
							Type:     schema.TypeString,
							Optional: true,
							Description: `The default Firebase Realtime Database instance name, in the format: projectId
Though rare, your projectId might already be used as the name for an existing Realtime Database instance in another project (learn more about database sharding).
In these cases, your projectId is appended with a hyphen then five alphanumeric characters to create your default Realtime Database instance name.
For example, if your projectId is myproject123, your default database instance name might be: myproject123-a5c16`,
						},
						"storage_bucket": {
							Type:        schema.TypeString,
							Optional:    true,
							Description: `The default Cloud Storage for Firebase storage bucket, in the format: projectId.appspot.com`,
						},
					},
				},
			},
			"display_name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The user-assigned display name of the Project.`,
			},
			"name": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The fully qualified resource name of the Project, in the format: projects/projectId`,
			},
			"project_id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `Immutable. The globally unique, user-assigned ID of the Project.`,
			},
			"project_number": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: `The globally unique, Google-assigned identifier of the Project.`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
	}
}

func resourceFirebaseProjectCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	obj := make(map[string]interface{})
	url, err := replaceVars(d, config, "{{FirebaseBasePath}}projects/{{project}}:addFirebase")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Project: %#v", obj)
	project, err := getProject(d, config)
	if err != nil {
		return err
	}
	res, err := sendRequestWithTimeout(config, "POST", project, url, obj, d.Timeout(schema.TimeoutCreate))
	if err != nil {
		return fmt.Errorf("Error creating Project: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "projects/{{project}}/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = firebaseOperationWaitTime(
		config, res, project, "Creating Project",
		int(d.Timeout(schema.TimeoutCreate).Minutes()))

	if err != nil {
		// The resource didn't actually create
		d.SetId("")
		return fmt.Errorf("Error waiting to create Project: %s", err)
	}

	log.Printf("[DEBUG] Finished creating Project %q: %#v", d.Id(), res)

	return resourceFirebaseProjectRead(d, meta)
}

func resourceFirebaseProjectRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	url, err := replaceVars(d, config, "{{FirebaseBasePath}}projects/{{project}}/{{name}}")
	if err != nil {
		return err
	}

	project, err := getProject(d, config)
	if err != nil {
		return err
	}
	res, err := sendRequest(config, "GET", project, url, nil)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("FirebaseProject %q", d.Id()))
	}

	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Project: %s", err)
	}

	if err := d.Set("name", flattenFirebaseProjectName(res["name"], d)); err != nil {
		return fmt.Errorf("Error reading Project: %s", err)
	}
	if err := d.Set("project_id", flattenFirebaseProjectProjectId(res["projectId"], d)); err != nil {
		return fmt.Errorf("Error reading Project: %s", err)
	}
	if err := d.Set("project_number", flattenFirebaseProjectProjectNumber(res["projectNumber"], d)); err != nil {
		return fmt.Errorf("Error reading Project: %s", err)
	}
	if err := d.Set("display_name", flattenFirebaseProjectDisplayName(res["displayName"], d)); err != nil {
		return fmt.Errorf("Error reading Project: %s", err)
	}
	if err := d.Set("resources", flattenFirebaseProjectResources(res["resources"], d)); err != nil {
		return fmt.Errorf("Error reading Project: %s", err)
	}

	return nil
}

func resourceFirebaseProjectUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	project, err := getProject(d, config)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})
	resourcesProp, err := expandFirebaseProjectResources(d.Get("resources"), d, config)
	if err != nil {
		return err
	} else if v, ok := d.GetOkExists("resources"); !isEmptyValue(reflect.ValueOf(v)) && (ok || !reflect.DeepEqual(v, resourcesProp)) {
		obj["resources"] = resourcesProp
	}

	url, err := replaceVars(d, config, "{{FirebaseBasePath}}projects/{{project}}/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Project %q: %#v", d.Id(), obj)
	res, err := sendRequestWithTimeout(config, "PUT", project, url, obj, d.Timeout(schema.TimeoutUpdate))

	if err != nil {
		return fmt.Errorf("Error updating Project %q: %s", d.Id(), err)
	}

	err = firebaseOperationWaitTime(
		config, res, project, "Updating Project",
		int(d.Timeout(schema.TimeoutUpdate).Minutes()))

	if err != nil {
		return err
	}

	return resourceFirebaseProjectRead(d, meta)
}

func resourceFirebaseProjectDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)

	project, err := getProject(d, config)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{FirebaseBasePath}}projects/{{project}}/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting Project %q", d.Id())

	res, err := sendRequestWithTimeout(config, "DELETE", project, url, obj, d.Timeout(schema.TimeoutDelete))
	if err != nil {
		return handleNotFoundError(err, d, "Project")
	}

	err = firebaseOperationWaitTime(
		config, res, project, "Deleting Project",
		int(d.Timeout(schema.TimeoutDelete).Minutes()))

	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Finished deleting Project %q: %#v", d.Id(), res)
	return nil
}

func resourceFirebaseProjectImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*Config)
	if err := parseImportId([]string{
		"projects/(?P<project>[^/]+)/(?P<name>[^/]+)",
		"(?P<project>[^/]+)/(?P<name>[^/]+)",
		"(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := replaceVars(d, config, "projects/{{project}}/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	return []*schema.ResourceData{d}, nil
}

func flattenFirebaseProjectName(v interface{}, d *schema.ResourceData) interface{} {
	return v
}

func flattenFirebaseProjectProjectId(v interface{}, d *schema.ResourceData) interface{} {
	return v
}

func flattenFirebaseProjectProjectNumber(v interface{}, d *schema.ResourceData) interface{} {
	return v
}

func flattenFirebaseProjectDisplayName(v interface{}, d *schema.ResourceData) interface{} {
	return v
}

func flattenFirebaseProjectResources(v interface{}, d *schema.ResourceData) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["hosting_site"] =
		flattenFirebaseProjectResourcesHostingSite(original["hostingSite"], d)
	transformed["realtime_database_instance"] =
		flattenFirebaseProjectResourcesRealtimeDatabaseInstance(original["realtimeDatabaseInstance"], d)
	transformed["storage_bucket"] =
		flattenFirebaseProjectResourcesStorageBucket(original["storageBucket"], d)
	transformed["location_id"] =
		flattenFirebaseProjectResourcesLocationId(original["locationId"], d)
	return []interface{}{transformed}
}
func flattenFirebaseProjectResourcesHostingSite(v interface{}, d *schema.ResourceData) interface{} {
	return v
}

func flattenFirebaseProjectResourcesRealtimeDatabaseInstance(v interface{}, d *schema.ResourceData) interface{} {
	return v
}

func flattenFirebaseProjectResourcesStorageBucket(v interface{}, d *schema.ResourceData) interface{} {
	return v
}

func flattenFirebaseProjectResourcesLocationId(v interface{}, d *schema.ResourceData) interface{} {
	return v
}

func expandFirebaseProjectResources(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	l := v.([]interface{})
	if len(l) == 0 || l[0] == nil {
		return nil, nil
	}
	raw := l[0]
	original := raw.(map[string]interface{})
	transformed := make(map[string]interface{})

	transformedHostingSite, err := expandFirebaseProjectResourcesHostingSite(original["hosting_site"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedHostingSite); val.IsValid() && !isEmptyValue(val) {
		transformed["hostingSite"] = transformedHostingSite
	}

	transformedRealtimeDatabaseInstance, err := expandFirebaseProjectResourcesRealtimeDatabaseInstance(original["realtime_database_instance"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedRealtimeDatabaseInstance); val.IsValid() && !isEmptyValue(val) {
		transformed["realtimeDatabaseInstance"] = transformedRealtimeDatabaseInstance
	}

	transformedStorageBucket, err := expandFirebaseProjectResourcesStorageBucket(original["storage_bucket"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedStorageBucket); val.IsValid() && !isEmptyValue(val) {
		transformed["storageBucket"] = transformedStorageBucket
	}

	transformedLocationId, err := expandFirebaseProjectResourcesLocationId(original["location_id"], d, config)
	if err != nil {
		return nil, err
	} else if val := reflect.ValueOf(transformedLocationId); val.IsValid() && !isEmptyValue(val) {
		transformed["locationId"] = transformedLocationId
	}

	return transformed, nil
}

func expandFirebaseProjectResourcesHostingSite(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseProjectResourcesRealtimeDatabaseInstance(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseProjectResourcesStorageBucket(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}

func expandFirebaseProjectResourcesLocationId(v interface{}, d TerraformResourceData, config *Config) (interface{}, error) {
	return v, nil
}
